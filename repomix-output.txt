This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
prisma/
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    api/
      auth/
        signin/
          route.ts
        signup/
          route.ts
      games/
        beer/
          route.ts
        beerpong/
          [id]/
            winners/
              route.ts
          leaderboard/
            route.ts
          matches/
            [id]/
              winners/
                route.ts
              route.ts
            route.ts
          route.ts
        darts/
          route.ts
        putting/
          route.ts
      icebreaker/
        answers/
          route.ts
        card/
          route.ts
      users/
        list/
          route.ts
        records/
          route.ts
        stats/
          route.ts
        route.ts
    games/
      page.tsx
    icebreaker/
      page.tsx
    menu/
      page.tsx
    party/
      page.tsx
    records/
      page.tsx
    signin/
      page.tsx
    signup/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    games/
      BeerGame.tsx
      BeerPongGame.tsx
      DartGame.tsx
      PuttingGame.tsx
    Leaderboard.tsx
    Navbar.tsx
  lib/
    beerpong.ts
    icebreaker.ts
    prisma.ts
  types/
    user.ts
.gitignore
.repomixignore
eslint.config.mjs
next.config.js
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  name      String
  photoUrl  String
  createdAt DateTime @default(now())
  
  // Game scores
  dartScores     DartScore[]
  puttingScores  PuttingScore[]
  beerScores     BeerScore[]
  
  // Beer pong relationships
  playerInTeam1  BeerPongMatch[] @relation("Team1")
  playerInTeam2  BeerPongMatch[] @relation("Team2")
  wonMatches     BeerPongMatch[] @relation("Winners")

  // Individual beer pong stats
  beerPongStats  BeerPongStats?

  // Icebreaker game
  assignedCard   IcebreakerCard?
  answersGiven   IcebreakerAnswer[] @relation("AnswerGiver")
  answersReceived IcebreakerAnswer[] @relation("AnswerReceiver")
}

model DartScore {
  id        String   @id @default(cuid())
  score     Int      // Out of 50
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

model PuttingScore {
  id        String   @id @default(cuid())
  score     Int      // Out of 10
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

model BeerScore {
  id        String   @id @default(cuid())
  time      Float    // Time in seconds
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
}

model BeerPongMatch {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  status    String   @default("ongoing") // ongoing, completed
  
  // Teams (1-2 players per team)
  team1Players User[] @relation("Team1")
  team2Players User[] @relation("Team2")
  
  // Winners
  winners     User[] @relation("Winners")
  
  // Optional team names
  team1Name   String?
  team2Name   String?
}

model BeerPongStats {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  wins      Int      @default(0)
  losses    Int      @default(0)
  winStreak Int      @default(0)
  bestStreak Int     @default(0)
  lastUpdated DateTime @default(now())
}

model IcebreakerCard {
  id        String   @id @default(cuid())
  cardId    Int      // ID from JSON file
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  answers   IcebreakerAnswer[]
}

model IcebreakerAnswer {
  id        String   @id @default(cuid())
  cardId    String
  card      IcebreakerCard @relation(fields: [cardId], references: [id])
  questionNumber Int
  giverId   String
  giver     User     @relation("AnswerGiver", fields: [giverId], references: [id])
  receiverId String
  receiver  User     @relation("AnswerReceiver", fields: [receiverId], references: [id])
  createdAt DateTime @default(now())

  @@unique([cardId, questionNumber, giverId])
}

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/next.svg
================
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================
File: public/vercel.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: src/app/api/auth/signin/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function POST(req: Request) {
  try {
    const { username } = await req.json();

    if (!username) {
      return NextResponse.json(
        { error: 'Käyttäjänimi vaaditaan' },
        { status: 400 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { username },
    });

    if (!user) {
      return NextResponse.json(
        { error: 'Käyttäjää ei löydy' },
        { status: 404 }
      );
    }

    return NextResponse.json(user);
  } catch (error) {
    console.error('Virhe sisäänkirjautumisessa:', error);
    return NextResponse.json(
      { error: 'Virhe sisäänkirjautumisessa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/auth/signup/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function POST(req: Request) {
  try {
    const { username, name, photoUrl } = await req.json();

    if (!username || !name || !photoUrl) {
      return NextResponse.json(
        { error: 'Käyttäjänimi, nimi ja profiilikuva vaaditaan' },
        { status: 400 }
      );
    }

    // Check if username is already taken
    const existingUser = await prisma.user.findUnique({
      where: { username },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: 'Käyttäjänimi on jo käytössä' },
        { status: 400 }
      );
    }

    // Create new user
    const user = await prisma.user.create({
      data: {
        username,
        name,
        photoUrl,
      },
    });

    return NextResponse.json(user);
  } catch (error) {
    console.error('Virhe käyttäjän luonnissa:', error);
    return NextResponse.json(
      { error: 'Virhe käyttäjän luonnissa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beer/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Get leaderboard
export async function GET() {
  try {
    const scores = await prisma.beerScore.findMany({
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      },
      orderBy: {
        time: 'asc' // Fastest times first
      },
      take: 10 // Top 10 scores
    });

    return NextResponse.json(scores);
  } catch (error) {
    console.error('Error fetching beer scores:', error);
    return NextResponse.json(
      { error: 'Error fetching scores' },
      { status: 500 }
    );
  }
}

// Submit new score
export async function POST(req: Request) {
  try {
    const { time, userId } = await req.json();

    if (typeof time !== 'number' || time < 0) {
      return NextResponse.json(
        { error: 'Invalid time. Must be a positive number.' },
        { status: 400 }
      );
    }

    const beerScore = await prisma.beerScore.create({
      data: {
        time,
        userId
      },
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      }
    });

    return NextResponse.json(beerScore);
  } catch (error) {
    console.error('Error creating beer score:', error);
    return NextResponse.json(
      { error: 'Error saving score' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/[id]/winners/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { updateBeerPongStats } from "@/lib/beerpong";

type Player = {
  id: string;
  name: string;
  username: string;
  photoUrl: string | null;
};

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: matchId } = await params;
    const { winnerIds } = await req.json();

    if (!winnerIds || !Array.isArray(winnerIds) || winnerIds.length === 0) {
      return NextResponse.json(
        { error: "Winner IDs are required" },
        { status: 400 }
      );
    }

    // Get the match to find all players
    const match = await prisma.beerPongMatch.findUnique({
      where: { id: matchId },
      include: {
        team1Players: true,
        team2Players: true,
      },
    });

    if (!match) {
      return NextResponse.json(
        { error: "Match not found" },
        { status: 404 }
      );
    }

    if (match.status === "completed") {
      return NextResponse.json(
        { error: "Match already completed" },
        { status: 400 }
      );
    }

    // Update match with winners
    const updatedMatch = await prisma.beerPongMatch.update({
      where: { id: matchId },
      data: {
        winners: {
          connect: winnerIds.map((id: string) => ({ id })),
        },
        status: "completed",
      },
      include: {
        team1Players: true,
        team2Players: true,
        winners: true,
      },
    });

    // Update player statistics
    const allPlayerIds = [
      ...match.team1Players.map((p: Player) => p.id),
      ...match.team2Players.map((p: Player) => p.id),
    ];
    const loserIds = allPlayerIds.filter(id => !winnerIds.includes(id));

    await updateBeerPongStats(winnerIds, loserIds);

    return NextResponse.json(updatedMatch);
  } catch (error) {
    console.error("Error updating match winners:", error);
    return NextResponse.json(
      { error: "Error updating match" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/leaderboard/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

interface User {
  id: string;
  name: string;
  username: string;
  photoUrl: string;
}

interface Match {
  id: string;
  status: 'ongoing' | 'completed';
  team1Players: User[];
  team2Players: User[];
  winners: User[];
  team1Name?: string;
  team2Name?: string;
  createdAt: string | Date;
}

interface PlayerStats {
  id: string;
  name: string;
  username: string;
  photoUrl: string;
  wins: number;
  losses: number;
  winStreak: number;
  bestStreak: number;
  games: string[]; // Array of match IDs to track game sequence
}

export async function GET() {
  try {
    const matches = await prisma.beerPongMatch.findMany({
      where: {
        status: "completed"
      },
      include: {
        team1Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        team2Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        winners: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
    });

    // Calculate stats for each player
    const playerStats: Record<string, PlayerStats> = {};

    // Process all matches to build stats
    matches.forEach((match: Match) => {
      const allPlayers = [...match.team1Players, ...match.team2Players];
      const winnerIds = new Set(match.winners.map((w: User) => w.id));

      allPlayers.forEach((player: User) => {
        if (!playerStats[player.id]) {
          playerStats[player.id] = {
            id: player.id,
            name: player.name,
            username: player.username,
            photoUrl: player.photoUrl,
            wins: 0,
            losses: 0,
            winStreak: 0,
            bestStreak: 0,
            games: [],
          };
        }

        const stats = playerStats[player.id];
        const won = winnerIds.has(player.id);
        
        if (won) {
          stats.wins++;
          stats.winStreak++;
          stats.bestStreak = Math.max(stats.bestStreak, stats.winStreak);
        } else {
          stats.losses++;
          stats.winStreak = 0;
        }

        stats.games.push(match.id);
      });
    });

    // Convert to array and calculate percentages
    const leaderboard = Object.values(playerStats)
      .filter(player => player.wins + player.losses >= 3) // Only include players with 3+ games
      .map((player) => ({
        ...player,
        winPercentage: Math.round((player.wins / (player.wins + player.losses)) * 100),
        totalGames: player.wins + player.losses,
      }))
      .sort((a, b) => {
        // Sort by win percentage first, then by total games
        if (a.winPercentage !== b.winPercentage) {
          return b.winPercentage - a.winPercentage;
        }
        return b.totalGames - a.totalGames;
      });

    return NextResponse.json(leaderboard);
  } catch (error) {
    console.error("Error fetching leaderboard:", error);
    return NextResponse.json(
      { error: "Virhe tilastojen haussa" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/matches/[id]/winners/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function POST(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: matchId } = await params;
    const { winnerIds } = await req.json();

    if (!winnerIds || !Array.isArray(winnerIds) || winnerIds.length === 0) {
      return NextResponse.json(
        { error: "Winner IDs are required" },
        { status: 400 }
      );
    }

    // Update match with winners
    const updatedMatch = await prisma.beerPongMatch.update({
      where: { id: matchId },
      data: {
        winners: {
          connect: winnerIds.map((id: string) => ({ id })),
        },
        status: "completed",
      },
      include: {
        team1Players: true,
        team2Players: true,
        winners: true,
      },
    });

    return NextResponse.json(updatedMatch);
  } catch (error) {
    console.error("Error updating match winners:", error);
    return NextResponse.json(
      { error: "Error updating match" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/matches/[id]/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET(
  req: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: matchId } = await params;
    
    const match = await prisma.beerPongMatch.findUnique({
      where: { id: matchId },
      include: {
        team1Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        team2Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        winners: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
    });

    if (!match) {
      return NextResponse.json(
        { error: "Peliä ei löytynyt" },
        { status: 404 }
      );
    }

    return NextResponse.json(match);
  } catch (error) {
    console.error("Error fetching match:", error);
    return NextResponse.json(
      { error: "Virhe pelin haussa" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/matches/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function POST(req: Request) {
  try {
    const { team1PlayerIds, team2PlayerIds, team1Name, team2Name } = await req.json();

    if (!team1PlayerIds?.length || !team2PlayerIds?.length) {
      return NextResponse.json(
        { error: "Molemmissa joukkueissa tulee olla pelaajia" },
        { status: 400 }
      );
    }

    // Validate teams: ensure no team has more than 2 players
    if (team1PlayerIds.length > 2 || team2PlayerIds.length > 2) {
      return NextResponse.json(
        { error: 'Joukkueessa voi olla korkeintaan 2 pelaajaa' },
        { status: 400 }
      );
    }

    // Create new match
    const match = await prisma.beerPongMatch.create({
      data: {
        status: "ongoing",
        team1Players: {
          connect: team1PlayerIds.map((id: string) => ({ id })),
        },
        team2Players: {
          connect: team2PlayerIds.map((id: string) => ({ id })),
        },
        team1Name,
        team2Name,
      },
      include: {
        team1Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        team2Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
    });

    return NextResponse.json(match);
  } catch (error) {
    console.error("Error creating match:", error);
    return NextResponse.json(
      { error: "Virhe pelin luonnissa" },
      { status: 500 }
    );
  }
}

export async function GET() {
  try {
    const matches = await prisma.beerPongMatch.findMany({
      include: {
        team1Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        team2Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        winners: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return NextResponse.json(matches);
  } catch (error) {
    console.error("Error fetching matches:", error);
    return NextResponse.json(
      { error: "Virhe pelien haussa" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/beerpong/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Get all matches
export async function GET() {
  try {
    const matches = await prisma.beerPongMatch.findMany({
      include: {
        team1Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        team2Players: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
        winners: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return NextResponse.json(matches);
  } catch (error) {
    console.error('Virhe pelien haussa:', error);
    return NextResponse.json(
      { error: 'Virhe pelien haussa' },
      { status: 500 }
    );
  }
}

// Create new match
export async function POST(req: Request) {
  try {
    const { team1PlayerIds, team2PlayerIds, team1Name, team2Name } = await req.json();

    // Validate teams
    if (!team1PlayerIds?.length || !team2PlayerIds?.length) {
      return NextResponse.json(
        { error: 'Molemmissa joukkueissa tulee olla pelaajia' },
        { status: 400 }
      );
    }

    if (team1PlayerIds.length > 2 || team2PlayerIds.length > 2) {
      return NextResponse.json(
        { error: 'Joukkueessa voi olla korkeintaan 2 pelaajaa' },
        { status: 400 }
      );
    }

    // Create match
    const match = await prisma.beerPongMatch.create({
      data: {
        team1Players: {
          connect: team1PlayerIds.map((id: string) => ({ id })),
        },
        team2Players: {
          connect: team2PlayerIds.map((id: string) => ({ id })),
        },
        team1Name,
        team2Name,
      },
      include: {
        team1Players: true,
        team2Players: true,
      },
    });

    return NextResponse.json(match);
  } catch (error) {
    console.error('Virhe pelin luonnissa:', error);
    return NextResponse.json(
      { error: 'Virhe pelin luonnissa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/darts/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Get leaderboard
export async function GET() {
  try {
    const scores = await prisma.dartScore.findMany({
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      },
      orderBy: {
        score: 'desc'
      },
      take: 10 // Top 10 scores
    });

    return NextResponse.json(scores);
  } catch (error) {
    console.error('Error fetching dart scores:', error);
    return NextResponse.json(
      { error: 'Error fetching scores' },
      { status: 500 }
    );
  }
}

// Submit new score
export async function POST(req: Request) {
  try {
    const { score, userId } = await req.json();

    if (typeof score !== 'number' || score < 0 || score > 50) {
      return NextResponse.json(
        { error: 'Invalid score. Must be between 0 and 50.' },
        { status: 400 }
      );
    }

    const dartScore = await prisma.dartScore.create({
      data: {
        score,
        userId
      },
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      }
    });

    return NextResponse.json(dartScore);
  } catch (error) {
    console.error('Error creating dart score:', error);
    return NextResponse.json(
      { error: 'Error saving score' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/games/putting/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Get leaderboard
export async function GET() {
  try {
    const scores = await prisma.puttingScore.findMany({
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      },
      orderBy: {
        score: 'desc'
      },
      take: 10 // Top 10 scores
    });

    return NextResponse.json(scores);
  } catch (error) {
    console.error('Error fetching putting scores:', error);
    return NextResponse.json(
      { error: 'Error fetching scores' },
      { status: 500 }
    );
  }
}

// Submit new score
export async function POST(req: Request) {
  try {
    const { score, userId } = await req.json();

    if (typeof score !== 'number' || score < 0 || score > 10) {
      return NextResponse.json(
        { error: 'Invalid score. Must be between 0 and 10.' },
        { status: 400 }
      );
    }

    const puttingScore = await prisma.puttingScore.create({
      data: {
        score,
        userId
      },
      include: {
        user: {
          select: {
            name: true,
            username: true,
            photoUrl: true
          }
        }
      }
    });

    return NextResponse.json(puttingScore);
  } catch (error) {
    console.error('Error creating putting score:', error);
    return NextResponse.json(
      { error: 'Error saving score' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/icebreaker/answers/route.ts
================
import { NextResponse } from 'next/server';
import { submitAnswer, getParticipants } from '@/lib/icebreaker';

// Get all participants
export async function GET() {
  try {
    const participants = await getParticipants();
    return NextResponse.json(participants);
  } catch (error) {
    console.error('Virhe osallistujien haussa:', error);
    return NextResponse.json(
      { error: 'Virhe osallistujien haussa' },
      { status: 500 }
    );
  }
}

// Submit an answer
export async function POST(req: Request) {
  try {
    const { cardId, questionNumber, giverId, receiverId } = await req.json();

    if (!cardId) {
      return NextResponse.json(
        { error: 'Kortin tunniste puuttuu' },
        { status: 400 }
      );
    }

    if (!questionNumber) {
      return NextResponse.json(
        { error: 'Kysymyksen numero puuttuu' },
        { status: 400 }
      );
    }

    if (!giverId) {
      return NextResponse.json(
        { error: 'Vastaajan tunniste puuttuu' },
        { status: 400 }
      );
    }

    if (!receiverId) {
      return NextResponse.json(
        { error: 'Valitun henkilön tunniste puuttuu' },
        { status: 400 }
      );
    }

    await submitAnswer(cardId, questionNumber, giverId, receiverId);
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Virhe vastauksen tallennuksessa:', error);
    return NextResponse.json(
      { error: 'Virhe vastauksen tallennuksessa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/icebreaker/card/route.ts
================
import { NextResponse } from 'next/server';
import { assignCardToUser, getCardWithAnswers } from '@/lib/icebreaker';

// Get user's assigned card
export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const userId = url.searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'Käyttäjän tunniste puuttuu' },
        { status: 400 }
      );
    }

    const card = await getCardWithAnswers(userId);
    
    if (!card) {
      try {
        // Assign new card if user doesn't have one
        const newCard = await assignCardToUser(userId);
        return NextResponse.json({
          dbId: newCard.id,
          cardId: newCard.cardId,
          title: `KORTTI ${newCard.cardId}`,
          subtitle: `Setti ${Math.ceil(newCard.cardId / 20)}`,
          questions: newCard.questions,
          answers: {}
        });
      } catch (err) {
        console.error('Virhe kortin luonnissa:', err);
        throw new Error('Kortin luonti epäonnistui');
      }
    }

    return NextResponse.json(card);
  } catch (error) {
    console.error('Virhe kortin haussa:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Virhe kortin haussa'
      },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/list/route.ts
================
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

export async function GET() {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        name: true,
        username: true,
        photoUrl: true,
      },
      orderBy: {
        name: 'asc',
      },
    });

    return NextResponse.json(users);
  } catch (error) {
    console.error("Error fetching users:", error);
    return NextResponse.json(
      { error: "Virhe käyttäjien haussa" },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/records/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const userId = url.searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'Käyttäjän ID vaaditaan' },
        { status: 400 }
      );
    }

    const [dartScores, puttingScores, beerScores] = await Promise.all([
      prisma.dartScore.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.puttingScore.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
      }),
      prisma.beerScore.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
      }),
    ]);

    return NextResponse.json({
      dartScores,
      puttingScores,
      beerScores,
    });
  } catch (error) {
    console.error('Virhe tulosten haussa:', error);
    return NextResponse.json(
      { error: 'Virhe tulosten haussa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/stats/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const userId = url.searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'Käyttäjän tunniste puuttuu' },
        { status: 400 }
      );
    }

    // Get answers given by the user
    const answersGiven = await prisma.icebreakerAnswer.count({
      where: { giverId: userId }
    });

    // Get answers where user is selected
    const timesSelected = await prisma.icebreakerAnswer.count({
      where: { receiverId: userId }
    });

    // Get unique cards where user appears
    const uniqueCardsWhereSelected = await prisma.icebreakerAnswer.findMany({
      where: { receiverId: userId },
      select: {
        cardId: true
      },
      distinct: ['cardId']
    });

    // Get the user's own card and its completion
    const userCard = await prisma.icebreakerCard.findFirst({
      where: { userId },
      include: {
        answers: true
      }
    });

    return NextResponse.json({
      answersGiven,
      timesSelected,
      uniqueCardsCount: uniqueCardsWhereSelected.length,
      ownCardProgress: userCard ? userCard.answers.length : 0
    });
  } catch (error) {
    console.error('Virhe tilastojen haussa:', error);
    return NextResponse.json(
      { error: 'Virhe tilastojen haussa' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/route.ts
================
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET() {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        name: true,
        username: true,
        photoUrl: true,
      },
    });

    return NextResponse.json(users);
  } catch (error) {
    console.error('Virhe käyttäjien haussa:', error);
    return NextResponse.json(
      { error: 'Virhe käyttäjien haussa' },
      { status: 500 }
    );
  }
}

================
File: src/app/games/page.tsx
================
"use client";

import { useState } from "react";
import dynamic from "next/dynamic";

// Dynamically import game components to prevent SSR issues
const DartGame = dynamic(() => import("@/components/games/DartGame"));
const PuttingGame = dynamic(() => import("@/components/games/PuttingGame"));
const BeerPongGame = dynamic(() => import("@/components/games/BeerPongGame"));
const BeerGame = dynamic(() => import("@/components/games/BeerGame"));

const tabs = [
  { id: "darts", name: "Tikanheitto" },
  { id: "putting", name: "Puttaus" },
  { id: "beerpong", name: "Beer Pong" },
  { id: "beer", name: "Kaljakellotus" },
];

export default function Games() {
  const [activeTab, setActiveTab] = useState("darts");

  return (
    <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white rounded-xl shadow-lg p-6 mt-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-6">Pelit</h1>

          {/* Tabs */}
          <div className="border-b border-gray-200">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`
                    py-4 px-1 border-b-2 font-medium text-sm
                    ${
                      activeTab === tab.id
                        ? "border-blue-500 text-blue-600"
                        : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
                    }
                  `}
                >
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {/* Content */}
          <div className="mt-6">
            {activeTab === "darts" && <DartGame />}
            {activeTab === "putting" && <PuttingGame />}
            {activeTab === "beerpong" && <BeerPongGame />}
            {activeTab === "beer" && <BeerGame />}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/app/icebreaker/page.tsx
================
"use client";

import { useEffect, useState, useMemo } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";

interface User {
  id: string;
  name: string;
  username: string;
  photoUrl: string;
}

interface Question {
  number: number;
  text: string;
}

interface Card {
  dbId: string; // Changed from id to dbId
  cardId: number;
  title: string;
  subtitle: string;
  questions: Question[];
  answers: Record<number, User>;
}

export default function Icebreaker() {
  const [user, setUser] = useState<User | null>(null);
  const [card, setCard] = useState<Card | null>(null);
  const [participants, setParticipants] = useState<User[]>([]);
  const [selectedParticipant, setSelectedParticipant] = useState<string>("");
  const [activeQuestion, setActiveQuestion] = useState<number | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  const router = useRouter();

  useEffect(() => {
    const storedUser = sessionStorage.getItem("user");
    if (!storedUser) {
      router.push("/signin");
      return;
    }
    
    setUser(JSON.parse(storedUser));
  }, [router]);

  useEffect(() => {
    const fetchData = async () => {
      if (!user) return;

      try {
        // Fetch user's card
        const cardRes = await fetch(`/api/icebreaker/card?userId=${user.id}`);
        if (!cardRes.ok) throw new Error("Failed to fetch card");
        const cardData = await cardRes.json();
        setCard(cardData);

        // Fetch participants
        const participantsRes = await fetch("/api/icebreaker/answers");
        if (!participantsRes.ok) throw new Error("Failed to fetch participants");
        const participantsData = await participantsRes.json();
        setParticipants(participantsData);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error loading game data");
      }
    };

    fetchData();
  }, [user]);

  // Get available participants for the current question
  const availableParticipants = useMemo(() => {
    if (!card || !participants) return [];

    // Initialize empty answers object if not present
    const answers = card.answers || {};

    // Get all user IDs that have been used in answers
    const usedParticipantIds = Object.values(answers).map((p: User) => p.id);

    // Filter out the current user and already used participants
    return participants.filter((p: User) => 
      p.id !== user?.id && !usedParticipantIds.includes(p.id)
    );
  }, [card, participants, user]);

  const handleSubmitAnswer = async (questionNumber: number) => {
    if (!user || !card || !selectedParticipant) return;

    setIsSubmitting(true);
    setError("");

    try {
      const response = await fetch("/api/icebreaker/answers", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          cardId: card.dbId, // Now using dbId instead of id
          questionNumber,
          giverId: user.id,
          receiverId: selectedParticipant,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Failed to submit answer");
      }

      // Refetch card data to update answers
      const cardRes = await fetch(`/api/icebreaker/card?userId=${user.id}`);
      if (!cardRes.ok) throw new Error("Failed to fetch updated card");
      const cardData = await cardRes.json();
      setCard(cardData);

      // Reset selection
      setSelectedParticipant("");
      setActiveQuestion(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to submit answer");
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!user || !card) {
    return (
      <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex items-center justify-center">
        <div className="text-2xl text-gray-600">Ladataan...</div>
      </div>
    );
  }

  const answeredQuestionsCount = Object.keys(card.answers || {}).length;
  const totalQuestions = card.questions.length;

  return (
    <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 px-4 py-2 sm:p-4">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white rounded-xl shadow-lg p-4 sm:p-8 mt-4 sm:mt-8">
          <h1 className="text-2xl sm:text-3xl font-bold text-gray-900 mb-2">{card.title}</h1>
          <p className="text-gray-600 mb-4 sm:mb-6">{card.subtitle}</p>

          <div className="bg-blue-50 p-4 rounded-lg mb-6">
            <p className="text-blue-800">
              Löydetty {answeredQuestionsCount}/{totalQuestions} henkilöä
            </p>
            <p className="text-sm text-blue-600 mt-1">
              Jokaiseen kysymykseen tarvitaan eri henkilö!
            </p>
          </div>

          <div className="space-y-4 sm:space-y-6">
            {card.questions.map((question) => (
              <div
                key={question.number}
                className={`p-4 rounded-lg border ${
                  card.answers?.[question.number]
                    ? "bg-green-50 border-green-200"
                    : activeQuestion === question.number
                    ? "bg-blue-50 border-blue-200"
                    : "bg-gray-50 border-gray-200"
                }`}
              >
                <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
                  <p className="text-base sm:text-lg flex-1">
                    {question.number}. {question.text}
                  </p>
                  {card.answers?.[question.number] ? (
                    <div className="flex items-center space-x-2 self-end sm:self-start">
                      <div className="relative w-8 h-8 sm:w-6 sm:h-6 rounded-full overflow-hidden">
                        <Image
                          src={card.answers[question.number].photoUrl}
                          alt={card.answers[question.number].name}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <span className="text-green-700">
                        {card.answers[question.number].name}
                      </span>
                    </div>
                  ) : activeQuestion === question.number ? (
                    <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 self-stretch">
                      <select
                        value={selectedParticipant}
                        onChange={(e) => setSelectedParticipant(e.target.value)}
                        className={`p-2 sm:p-1 border rounded text-base sm:text-sm min-w-[200px] ${
                          availableParticipants.length === 0 ? "bg-gray-100" : ""
                        }`}
                        disabled={availableParticipants.length === 0}
                      >
                        <option value="">
                          {availableParticipants.length === 0 
                            ? "Ei vapaita henkilöitä" 
                            : "Valitse henkilö"}
                        </option>
                        {availableParticipants.map((participant) => (
                          <option key={participant.id} value={participant.id}>
                            {participant.name}
                          </option>
                        ))}
                      </select>
                      <div className="flex gap-2">
                        <button
                          onClick={() => handleSubmitAnswer(question.number)}
                          disabled={!selectedParticipant || isSubmitting || availableParticipants.length === 0}
                          className="flex-1 sm:flex-none px-4 py-2 sm:py-1 bg-green-600 text-white rounded-lg sm:rounded hover:bg-green-700 disabled:opacity-50 text-base sm:text-sm"
                        >
                          {isSubmitting ? "..." : "Tallenna"}
                        </button>
                        <button
                          onClick={() => {
                            setActiveQuestion(null);
                            setSelectedParticipant("");
                          }}
                          className="flex-1 sm:flex-none px-4 py-2 sm:py-1 bg-gray-100 text-gray-700 rounded-lg sm:rounded hover:bg-gray-200 text-base sm:text-sm"
                        >
                          Peru
                        </button>
                      </div>
                    </div>
                  ) : (
                    <button
                      onClick={() => setActiveQuestion(question.number)}
                      disabled={availableParticipants.length === 0}
                      className="w-full sm:w-auto px-4 py-2 sm:py-1 bg-blue-600 text-white rounded-lg sm:rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-base sm:text-sm"
                    >
                      {availableParticipants.length === 0 
                        ? "Ei vapaita henkilöitä" 
                        : "Valitse henkilö"}
                    </button>
                  )}
                </div>
              </div>
            ))}
          </div>

          {error && (
            <div className="mt-4 p-4 bg-red-50 text-red-600 rounded-lg text-sm">
              {error}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/app/menu/page.tsx
================
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";

interface User {
  name: string;
}

export default function Menu() {
  const [user, setUser] = useState<User | null>(null);
  const router = useRouter();

  useEffect(() => {
    const storedUser = sessionStorage.getItem("user");
    if (!storedUser) {
      router.push("/signin");
      return;
    }
    
    setUser(JSON.parse(storedUser));
  }, [router]);

  if (!user) {
    return (
      <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex items-center justify-center">
        <div className="text-2xl text-gray-600">Ladataan...</div>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white rounded-xl shadow-lg p-8 mt-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-6">Ruokalista</h1>
          
          {/* Placeholder content */}
          <div className="space-y-8">
            <div>
              <h2 className="text-2xl font-semibold mb-4">Alkupalat</h2>
              <p className="text-gray-600 italic">Tulossa pian...</p>
            </div>

            <div>
              <h2 className="text-2xl font-semibold mb-4">Pääruoat</h2>
              <p className="text-gray-600 italic">Tulossa pian...</p>
            </div>

            <div>
              <h2 className="text-2xl font-semibold mb-4">Jälkiruoat</h2>
              <p className="text-gray-600 italic">Tulossa pian...</p>
            </div>

            <div>
              <h2 className="text-2xl font-semibold mb-4">Juomat</h2>
              <p className="text-gray-600 italic">Tulossa pian...</p>
            </div>

            <div className="bg-blue-50 p-4 rounded-lg">
              <p className="text-sm text-blue-600">
                Ruokalista päivitetään lähempänä juhlia. Ilmoitathan mahdolliset 
                ruoka-aineallergiat ja erikoisruokavaliot etukäteen.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/app/party/page.tsx
================
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";

interface User {
  username: string;
  name: string;
  photoUrl: string;
}

export default function Party() {
  const [user, setUser] = useState<User | null>(null);
  const router = useRouter();

  useEffect(() => {
    const storedUser = sessionStorage.getItem("user");
    if (!storedUser) {
      router.push("/signin");
      return;
    }
    
    try {
      setUser(JSON.parse(storedUser));
    } catch (error) {
      console.error("Virhe käyttäjätietojen lukemisessa:", error);
      router.push("/signin");
    }
  }, [router]);

  if (!user) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex items-center justify-center">
        <div className="text-2xl text-gray-600">Ladataan...</div>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4">
      <div className="max-w-4xl mx-auto space-y-8">
        <div className="bg-white rounded-xl shadow-lg p-8">
          <div className="flex items-center space-x-6">
            <div className="relative w-32 h-32 rounded-full overflow-hidden">
              <Image
                src={user.photoUrl}
                alt={user.name}
                fill
                style={{ objectFit: "cover" }}
              />
            </div>
            <div>
              <h1 className="text-3xl font-bold text-gray-900">{user.name}</h1>
              <p className="text-gray-600">@{user.username}</p>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-xl shadow-lg p-8">
          <h2 className="text-2xl font-semibold text-gray-900 mb-6">Tervetuloa juhliin!</h2>
          <p className="text-gray-600 mb-4">
            Pääset pelaamaan juhlapelejä ja katsomaan tuloksia yläpalkin linkeistä. 
            Kaikki tuloksesi tallennetaan automaattisesti ja voit seurata edistymistäsi 
            tuloshistoriasta.
          </p>
        </div>

        <button
          onClick={() => {
            sessionStorage.removeItem("user");
            router.push("/");
          }}
          className="px-6 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
        >
          Kirjaudu ulos
        </button>
      </div>
    </div>
  );
}

================
File: src/app/records/page.tsx
================
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";

interface Stats {
  answersGiven: number;
  timesSelected: number;
  uniqueCardsCount: number;
  ownCardProgress: number;
}

interface GameScore {
  id: string;
  score?: number;
  time?: number;
  createdAt: string;
}

interface Records {
  dartScores: GameScore[];
  puttingScores: GameScore[];
  beerScores: GameScore[];
}

const tabs = [
  { id: "darts", name: "Tikanheitto" },
  { id: "putting", name: "Puttaus" },
  { id: "beer", name: "Kaljakellotus" },
  { id: "icebreaker", name: "Tutustumispeli" },
];

export default function Records() {
  const [activeTab, setActiveTab] = useState("darts");
  const [records, setRecords] = useState<Records | null>(null);
  const [stats, setStats] = useState<Stats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const router = useRouter();

  useEffect(() => {
    const fetchData = async () => {
      try {
        const user = JSON.parse(sessionStorage.getItem("user") || "{}");
        if (!user.id) {
          router.push("/signin");
          return;
        }

        if (activeTab === "icebreaker") {
          const statsRes = await fetch(`/api/users/stats?userId=${user.id}`);
          if (!statsRes.ok) throw new Error("Failed to fetch stats");
          const statsData = await statsRes.json();
          setStats(statsData);
          setRecords(null);
        } else {
          setStats(null);
          const scoresRes = await fetch(`/api/users/records?userId=${user.id}`);
          if (!scoresRes.ok) throw new Error("Failed to fetch records");
          const scoresData = await scoresRes.json();
          setRecords(scoresData);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error loading game data");
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [router, activeTab]);

  const getStats = (scores: GameScore[]) => {
    if (!scores || scores.length === 0) return null;

    if ('score' in scores[0]) {
      const allScores = scores.map(s => s.score!);
      return {
        best: Math.max(...allScores),
        average: Math.round((allScores.reduce((a, b) => a + b, 0) / allScores.length) * 10) / 10,
        total: scores.length,
      };
    } else {
      const allTimes = scores.map(s => s.time!);
      return {
        best: Math.min(...allTimes),
        average: Math.round((allTimes.reduce((a, b) => a + b, 0) / allTimes.length) * 100) / 100,
        total: scores.length,
      };
    }
  };

  if (loading) {
    return (
      <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex items-center justify-center">
        <div className="text-2xl text-gray-600">Ladataan...</div>
      </div>
    );
  }

  return (
    <div className="min-h-[calc(100vh-64px)] bg-gradient-to-br from-blue-50 to-indigo-50 p-4">
      <div className="max-w-4xl mx-auto">
        <div className="bg-white rounded-xl shadow-lg p-6 mt-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-6">Pelituloksesi</h1>

          {/* Tabs */}
          <div className="border-b border-gray-200">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`
                    py-4 px-1 border-b-2 font-medium text-sm
                    ${
                      activeTab === tab.id
                        ? "border-blue-500 text-blue-600"
                        : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
                    }
                  `}
                >
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {/* Content */}
          <div className="mt-6">
            {/* Icebreaker Stats */}
            {activeTab === "icebreaker" && stats && (
              <div className="space-y-6">
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                  <div className="bg-blue-50 p-4 rounded-lg text-center">
                    <p className="text-sm text-blue-600 font-medium">Oma kortti</p>
                    <p className="text-2xl font-semibold text-blue-900">{stats.ownCardProgress}/20</p>
                    <p className="text-xs text-blue-500 mt-1">löydettyä henkilöä</p>
                  </div>
                  
                  <div className="bg-green-50 p-4 rounded-lg text-center">
                    <p className="text-sm text-green-600 font-medium">Vastauksia annettu</p>
                    <p className="text-2xl font-semibold text-green-900">{stats.answersGiven}</p>
                    <p className="text-xs text-green-500 mt-1">muiden kortteihin</p>
                  </div>

                  <div className="bg-purple-50 p-4 rounded-lg text-center">
                    <p className="text-sm text-purple-600 font-medium">Sinut löydetty</p>
                    <p className="text-2xl font-semibold text-purple-900">{stats.timesSelected}</p>
                    <p className="text-xs text-purple-500 mt-1">kertaa vastaukseksi</p>
                  </div>
                </div>

                <div className="bg-gray-50 p-4 rounded-lg">
                  <p className="text-sm text-gray-600">
                    Muista: tavoitteena on löytää henkilö jokaiseen korttisi väittämään. 
                    Samalla autat muita pelaajia täyttämään heidän korttinsa!
                  </p>
                </div>
              </div>
            )}

            {/* Darts */}
            {activeTab === "darts" && records?.dartScores && (
              <div>
                <div className="grid grid-cols-3 gap-4 mb-6">
                  {(() => {
                    const stats = getStats(records.dartScores);
                    return stats ? (
                      <>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Paras tulos</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.best}/50</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Keskiarvo</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.average}/50</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Pelatut pelit</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.total}</p>
                        </div>
                      </>
                    ) : null;
                  })()}
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Pisteet</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Päivämäärä</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {records.dartScores.map((score) => (
                      <tr key={score.id}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">{score.score}/50</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {new Date(score.createdAt).toLocaleDateString('fi-FI')}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {/* Putting */}
            {activeTab === "putting" && records?.puttingScores && (
              <div>
                <div className="grid grid-cols-3 gap-4 mb-6">
                  {(() => {
                    const stats = getStats(records.puttingScores);
                    return stats ? (
                      <>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Paras tulos</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.best}/10</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Keskiarvo</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.average}/10</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Pelatut pelit</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.total}</p>
                        </div>
                      </>
                    ) : null;
                  })()}
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Pisteet</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Päivämäärä</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {records.puttingScores.map((score) => (
                      <tr key={score.id}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">{score.score}/10</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {new Date(score.createdAt).toLocaleDateString('fi-FI')}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {/* Beer game */}
            {activeTab === "beer" && records?.beerScores && (
              <div>
                <div className="grid grid-cols-3 gap-4 mb-6">
                  {(() => {
                    const stats = getStats(records.beerScores);
                    return stats ? (
                      <>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Paras aika</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.best.toFixed(2)}s</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Keskiarvo</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.average.toFixed(2)}s</p>
                        </div>
                        <div className="bg-gray-50 p-4 rounded-lg text-center">
                          <p className="text-sm text-gray-500">Pelatut pelit</p>
                          <p className="text-2xl font-semibold text-gray-900">{stats.total}</p>
                        </div>
                      </>
                    ) : null;
                  })()}
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Aika</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Päivämäärä</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {records.beerScores.map((score) => (
                      <tr key={score.id}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm">{score.time?.toFixed(2)}s</td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                          {new Date(score.createdAt).toLocaleDateString('fi-FI')}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {error && (
              <div className="text-red-500 text-center py-4">{error}</div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/app/signin/page.tsx
================
"use client";

import { FormEvent, useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

export default function SignIn() {
  const [username, setUsername] = useState("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      const response = await fetch("/api/auth/signin", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ username }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Kirjautuminen epäonnistui");
      }

      const user = await response.json();
      sessionStorage.setItem("user", JSON.stringify(user));
      router.push("/party");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Kirjautuminen epäonnistui");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex flex-col items-center justify-center">
      <div className="w-full max-w-md bg-white rounded-xl shadow-lg p-8 space-y-8">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Tervetuloa takaisin!</h1>
          <p className="text-gray-600">Anna käyttäjänimesi jatkaaksesi</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label htmlFor="username" className="block text-sm font-medium text-gray-700 mb-2">
              Käyttäjänimi
            </label>
            <input
              id="username"
              type="text"
              required
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all outline-none"
              placeholder="Syötä käyttäjänimesi"
            />
          </div>

          {error && (
            <div className="text-red-500 text-sm text-center">{error}</div>
          )}

          <button
            type="submit"
            disabled={isLoading || !username}
            className="w-full py-3 px-4 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
          >
            {isLoading ? "Kirjaudutaan..." : "Kirjaudu sisään"}
          </button>

          <div className="text-center text-sm text-gray-600">
            Eikö sinulla ole tiliä?{" "}
            <Link href="/signup" className="text-blue-600 hover:underline">
              Rekisteröidy
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
}

================
File: src/app/signup/page.tsx
================
"use client";

import { FormEvent, useState } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";
import Image from "next/image";

export default function SignUp() {
  const [username, setUsername] = useState("");
  const [name, setName] = useState("");
  const [photo, setPhoto] = useState<File | null>(null);
  const [preview, setPreview] = useState<string>("");
  const [error, setError] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handlePhotoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setPhoto(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const uploadToCloudinary = async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', process.env.NEXT_PUBLIC_CLOUDINARY_UPLOAD_PRESET!);

    const response = await fetch(
      `https://api.cloudinary.com/v1_1/${process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME}/image/upload`,
      {
        method: 'POST',
        body: formData,
      }
    );

    if (!response.ok) {
      throw new Error('Kuvan lataus epäonnistui');
    }

    const data = await response.json();
    return data.secure_url;
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError("");

    try {
      if (!photo || !username || !name) {
        throw new Error('Täytä kaikki kentät');
      }

      // Upload image to Cloudinary
      const photoUrl = await uploadToCloudinary(photo);

      // Create user
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ username, name, photoUrl }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Rekisteröityminen epäonnistui');
      }

      const user = await response.json();
      sessionStorage.setItem("user", JSON.stringify(user));
      router.push('/party');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Rekisteröityminen epäonnistui');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex flex-col items-center justify-center">
      <div className="w-full max-w-md bg-white rounded-xl shadow-lg p-8 space-y-8">
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Liity mukaan juhliin!</h1>
          <p className="text-gray-600">Luo juhlaprofiilisi</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label htmlFor="username" className="block text-sm font-medium text-gray-700 mb-2">
              Käyttäjänimi
            </label>
            <input
              id="username"
              type="text"
              required
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all outline-none"
              placeholder="Valitse käyttäjänimi"
            />
          </div>

          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-2">
              Nimi
            </label>
            <input
              id="name"
              type="text"
              required
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all outline-none"
              placeholder="Syötä nimesi"
            />
          </div>

          <div>
            <label htmlFor="photo" className="block text-sm font-medium text-gray-700 mb-2">
              Profiilikuva
            </label>
            <div className="mt-1 flex flex-col items-center space-y-4">
              {preview ? (
                <div className="relative w-32 h-32 rounded-full overflow-hidden">
                  <Image
                    src={preview}
                    alt={name}
                    fill
                    style={{ objectFit: "cover" }}
                  />
                </div>
              ) : (
                <div className="w-32 h-32 rounded-full bg-gray-100 flex items-center justify-center">
                  <svg
                    className="w-12 h-12 text-gray-400"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
                    />
                  </svg>
                </div>
              )}
              <input
                id="photo"
                type="file"
                accept="image/*"
                required
                onChange={handlePhotoChange}
                className="hidden"
              />
              <button
                type="button"
                onClick={() => document.getElementById("photo")?.click()}
                className="px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors"
              >
                {preview ? "Vaihda kuva" : "Lataa kuva"}
              </button>
            </div>
          </div>

          {error && (
            <div className="text-red-500 text-sm text-center">{error}</div>
          )}

          <button
            type="submit"
            disabled={isLoading || !username || !name || !photo}
            className="w-full py-3 px-4 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
          >
            {isLoading ? "Luodaan tiliä..." : "Luo tili"}
          </button>

          <div className="text-center text-sm text-gray-600">
            Onko sinulla jo tili?{" "}
            <Link href="/signin" className="text-blue-600 hover:underline">
              Kirjaudu sisään
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
}

================
File: src/app/globals.css
================
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

================
File: src/app/layout.tsx
================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Navbar from "@/components/Navbar";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "30v Juhlat",
  description: "Tervetuloa juhlimaan",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="fi">
      <body className={inter.className}>
        <Navbar />
        {children}
      </body>
    </html>
  );
}

================
File: src/app/page.tsx
================
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import Link from "next/link";

export default function Home() {
  const router = useRouter();

  useEffect(() => {
    const user = sessionStorage.getItem("user");
    if (user) {
      router.push("/party");
    }
  }, [router]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-50 p-4 flex flex-col items-center justify-center">
      <div className="w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-4xl font-bold text-gray-900 mb-4">
            Tervetuloa juhliin!
          </h1>
          <p className="text-xl text-gray-600">
            Liity mukaan ja jaa hetkesi
          </p>
        </div>

        <div className="space-y-4">
          <Link
            href="/signin"
            className="w-full flex items-center justify-center py-3 px-4 bg-white text-blue-600 rounded-lg font-medium hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all border border-gray-200"
          >
            Kirjaudu sisään
          </Link>
          <Link
            href="/signup"
            className="w-full flex items-center justify-center py-3 px-4 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all"
          >
            Luo tili
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/games/BeerGame.tsx
================
"use client";

import { useState, useEffect, useRef } from "react";
import Leaderboard from "@/components/Leaderboard";

interface Score {
  id: string;
  time: number;
  createdAt: string;
  user: {
    name: string;
    username: string;
    photoUrl: string;
  };
}

export default function BeerGame() {
  const [isRunning, setIsRunning] = useState(false);
  const [time, setTime] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  const [leaderboard, setLeaderboard] = useState<Score[]>([]);
  const timerRef = useRef<number | undefined>(undefined);
  const startTimeRef = useRef<number>(0);

  // Fetch leaderboard
  const fetchLeaderboard = async () => {
    try {
      const response = await fetch("/api/games/beer");
      if (!response.ok) throw new Error("Tulosten haku epäonnistui");
      const data = await response.json();
      setLeaderboard(data);
    } catch (err) {
      console.error("Virhe tulosten haussa:", err);
    }
  };

  useEffect(() => {
    fetchLeaderboard();
    return () => {
      if (timerRef.current !== undefined) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  const startTimer = () => {
    setIsRunning(true);
    setTime(0);
    startTimeRef.current = Date.now();
    timerRef.current = window.setInterval(() => {
      setTime((Date.now() - startTimeRef.current) / 1000);
    }, 10);
  };

  const stopTimer = async () => {
    if (timerRef.current !== undefined) {
      clearInterval(timerRef.current);
      timerRef.current = undefined;
    }
    setIsRunning(false);
    const finalTime = (Date.now() - startTimeRef.current) / 1000;
    await submitScore(finalTime);
  };

  const submitScore = async (finalTime: number) => {
    setIsSubmitting(true);
    setError("");

    try {
      const user = JSON.parse(sessionStorage.getItem("user") || "{}");
      if (!user.id) throw new Error("Kirjaudu sisään tallentaaksesi tuloksen");

      const response = await fetch("/api/games/beer", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          time: finalTime,
          userId: user.id,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Ajan tallennus epäonnistui");
      }

      setTime(0);
      fetchLeaderboard();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Ajan tallennus epäonnistui");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="space-y-8">
      <div className="max-w-md mx-auto">
        <h2 className="text-2xl font-bold text-gray-900 mb-4">
          Kaljakellotus
        </h2>
        <div className="space-y-6">
          <div className="text-center">
            <div className="text-6xl font-mono mb-4">
              {time.toFixed(2)}s
            </div>
            {!isRunning ? (
              <button
                onClick={startTimer}
                disabled={isSubmitting}
                className="w-full py-3 px-4 bg-green-600 text-white rounded-lg font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Käynnistä ajanotto
              </button>
            ) : (
              <button
                onClick={stopTimer}
                className="w-full py-3 px-4 bg-red-600 text-white rounded-lg font-medium hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
              >
                Pysäytä ajanotto
              </button>
            )}
          </div>

          {error && (
            <div className="text-red-500 text-sm text-center">{error}</div>
          )}

          <div className="text-sm text-gray-600">
            <p>Ohjeet:</p>
            <ol className="list-decimal pl-4 space-y-1">
              <li>Paina &quot;Käynnistä ajanotto&quot; kun olet valmis</li>
              <li>Juo kaljas</li>
              <li>Paina &quot;Pysäytä ajanotto&quot; kun olet valmis</li>
              <li>Aikasi tallennetaan automaattisesti</li>
            </ol>
          </div>
        </div>
      </div>

      <div>
        <h3 className="text-xl font-semibold text-gray-900 mb-4">Tulostaulu</h3>
        <Leaderboard scores={leaderboard} type="time" />
      </div>
    </div>
  );
}

================
File: src/components/games/BeerPongGame.tsx
================
import { FC, useState, useEffect } from "react";
import { User } from "@/types/user";
import Image from "next/image";

interface Match {
  id: string;
  status: 'ongoing' | 'completed';
  team1Players: User[];
  team2Players: User[];
  winners: User[];
  team1Name?: string;
  team2Name?: string;
  createdAt: string;
}

const BeerPongGame: FC = () => {
  const [availablePlayers, setAvailablePlayers] = useState<User[]>([]);
  const [team1Players, setTeam1Players] = useState<User[]>([]);
  const [team2Players, setTeam2Players] = useState<User[]>([]);
  const [team1Name, setTeam1Name] = useState("");
  const [team2Name, setTeam2Name] = useState("");
  const [isCreating, setIsCreating] = useState(false);
  const [matches, setMatches] = useState<Match[]>([]);
  const [isSettingWinner, setIsSettingWinner] = useState(false);

  const getAvailablePlayers = (currentTeam: User[], otherTeam: User[]) => {
    // Ensure we have arrays to work with
    const safeCurrentTeam = currentTeam || [];
    const safeOtherTeam = otherTeam || [];
    
    // Filter out players that are already selected in either team
    return availablePlayers.filter(player => 
      !safeCurrentTeam.some(p => p?.id === player.id) && 
      !safeOtherTeam.some(p => p?.id === player.id)
    );
  };

  const handleCreateMatch = async () => {
    if (team1Players.length === 0 || team2Players.length === 0) {
      alert("Molemmissa joukkueissa tulee olla pelaajia");
      return;
    }
    
    setIsCreating(true);
    try {
      const response = await fetch("/api/games/beerpong/matches", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          team1PlayerIds: team1Players.map(p => p.id),
          team2PlayerIds: team2Players.map(p => p.id),
          team1Name: team1Name || undefined,
          team2Name: team2Name || undefined
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to create match");
      }

      // Refresh matches
      fetchMatches();

      // Reset form
      setTeam1Players([]);
      setTeam2Players([]);
      setTeam1Name("");
      setTeam2Name("");
    } catch (error) {
      console.error("Error creating match:", error);
      alert("Virhe pelin luonnissa");
    } finally {
      setIsCreating(false);
    }
  };

  const handleSetWinner = async (matchId: string, winnerTeam: 'team1' | 'team2') => {
    setIsSettingWinner(true);
    try {
      const match = matches.find(m => m.id === matchId);
      if (!match) return;

      const winners = winnerTeam === 'team1' ? match.team1Players : match.team2Players;
      const response = await fetch(`/api/games/beerpong/matches/${matchId}/winners`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          winnerIds: winners.map(p => p.id)
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to set winner");
      }

      // Refresh matches
      fetchMatches();
    } catch (error) {
      console.error("Error setting winner:", error);
      alert("Virhe voittajan asettamisessa");
    } finally {
      setIsSettingWinner(false);
    }
  };

  const fetchMatches = async () => {
    try {
      const response = await fetch("/api/games/beerpong/matches");
      if (!response.ok) throw new Error("Failed to fetch matches");
      const data = await response.json();
      setMatches(data);
    } catch (error) {
      console.error("Error fetching matches:", error);
      alert("Virhe pelien haussa");
    }
  };

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await fetch("/api/users");
        if (!response.ok) throw new Error("Failed to fetch players");
        const data = await response.json();
        setAvailablePlayers(data);
      } catch (error) {
        console.error("Error fetching players:", error);
        alert("Virhe pelaajien haussa");
      }
    };
    
    fetchPlayers();
    fetchMatches();
  }, []);

  return (
    <div className="space-y-6">
      {/* Create new game */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">Uusi peli</h2>

        {/* Instructions */}
        <div className="bg-blue-50 p-4 rounded-lg mb-6">
          <h3 className="font-medium text-blue-900 mb-2">Pelin luonti:</h3>
          <ol className="text-sm text-blue-700 space-y-1 list-decimal pl-4">
            <li>Valitse 1-2 pelaajaa kumpaankin joukkueeseen</li>
            <li>Halutessasi voit nimetä joukkueet</li>
          </ol>
        </div>

        <div className="space-y-4">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {/* Team 1 */}
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Joukkue 1 nimi (valinnainen)
                </label>
                <input
                  type="text"
                  value={team1Name}
                  onChange={(e) => setTeam1Name(e.target.value)}
                  className="w-full border rounded-lg p-2"
                  placeholder="Anna joukkueen nimi"
                />
              </div>
              
              {/* Team 1 Player 1 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Pelaaja 1
                </label>
                <select
                  value={team1Players[0]?.id || ''}
                  onChange={(e) => {
                    const player = availablePlayers.find(p => p.id === e.target.value);
                    if (player) {
                      setTeam1Players([player, ...team1Players.slice(1)]);
                    } else {
                      setTeam1Players(team1Players.slice(1));
                    }
                  }}
                  className="w-full border rounded-lg p-2"
                >
                  <option value="">Valitse pelaaja</option>
                  {getAvailablePlayers(team1Players.slice(1), team2Players).map(player => (
                    <option key={player.id} value={player.id}>{player.name}</option>
                  ))}
                </select>
              </div>

              {/* Team 1 Player 2 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Pelaaja 2 (valinnainen)
                </label>
                <select
                  value={team1Players[1]?.id || ''}
                  onChange={(e) => {
                    const player = availablePlayers.find(p => p.id === e.target.value);
                    if (player) {
                      setTeam1Players([...team1Players.slice(0, 1), player]);
                    } else {
                      setTeam1Players(team1Players.slice(0, 1));
                    }
                  }}
                  className="w-full border rounded-lg p-2"
                  disabled={!team1Players[0]} // Disable if first player not selected
                >
                  <option value="">Valitse pelaaja</option>
                  {team1Players[0] && getAvailablePlayers([team1Players[0]], team2Players).map(player => (
                    <option key={player.id} value={player.id}>{player.name}</option>
                  ))}
                </select>
              </div>
            </div>

            {/* Team 2 */}
            <div className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Joukkue 2 nimi (valinnainen)
                </label>
                <input
                  type="text"
                  value={team2Name}
                  onChange={(e) => setTeam2Name(e.target.value)}
                  className="w-full border rounded-lg p-2"
                  placeholder="Anna joukkueen nimi"
                />
              </div>

              {/* Team 2 Player 1 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Pelaaja 1
                </label>
                <select
                  value={team2Players[0]?.id || ''}
                  onChange={(e) => {
                    const player = availablePlayers.find(p => p.id === e.target.value);
                    if (player) {
                      setTeam2Players([player, ...team2Players.slice(1)]);
                    } else {
                      setTeam2Players(team2Players.slice(1));
                    }
                  }}
                  className="w-full border rounded-lg p-2"
                >
                  <option value="">Valitse pelaaja</option>
                  {getAvailablePlayers(team2Players.slice(1), team1Players).map(player => (
                    <option key={player.id} value={player.id}>{player.name}</option>
                  ))}
                </select>
              </div>

              {/* Team 2 Player 2 */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Pelaaja 2 (valinnainen)
                </label>
                <select
                  value={team2Players[1]?.id || ''}
                  onChange={(e) => {
                    const player = availablePlayers.find(p => p.id === e.target.value);
                    if (player) {
                      setTeam2Players([...team2Players.slice(0, 1), player]);
                    } else {
                      setTeam2Players(team2Players.slice(0, 1));
                    }
                  }}
                  className="w-full border rounded-lg p-2"
                  disabled={!team2Players[0]} // Disable if first player not selected
                >
                  <option value="">Valitse pelaaja</option>
                  {team2Players[0] && getAvailablePlayers([team2Players[0]], team1Players).map(player => (
                    <option key={player.id} value={player.id}>{player.name}</option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          <button
            onClick={handleCreateMatch}
            disabled={isCreating || !team1Players[0] || !team2Players[0]}
            className="w-full py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {isCreating ? "Luodaan..." : "Luo peli"}
          </button>
        </div>
      </div>

      {/* Active games */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">Käynnissä olevat pelit</h2>
        <div className="space-y-4">
          {matches.filter(match => match.status === 'ongoing').map(match => (
            <div key={match.id} className="border rounded-lg p-4">
              <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                <div className="flex-1 mb-2 sm:mb-0">
                  <div className="font-medium">
                    {match.team1Name || `Joukkue ${match.team1Players.map(p => p.name).join(' & ')}`}
                    <span className="mx-2 text-gray-400">vs</span>
                    {match.team2Name || `Joukkue ${match.team2Players.map(p => p.name).join(' & ')}`}
                  </div>
                  <div className="text-sm text-gray-500 mt-1">
                    Luotu: {new Date(match.createdAt).toLocaleString('fi-FI')}
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => handleSetWinner(match.id, 'team1')}
                    disabled={isSettingWinner}
                    className="px-3 py-1 bg-blue-100 text-blue-800 rounded hover:bg-blue-200"
                  >
                    Joukkue 1 voitti
                  </button>
                  <button
                    onClick={() => handleSetWinner(match.id, 'team2')}
                    disabled={isSettingWinner}
                    className="px-3 py-1 bg-purple-100 text-purple-800 rounded hover:bg-purple-200"
                  >
                    Joukkue 2 voitti
                  </button>
                </div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  {match.team1Players.map(player => (
                    <div key={player.id} className="flex items-center mb-1">
                      <div className="relative w-6 h-6 rounded-full overflow-hidden mr-2">
                        <Image
                          src={player.photoUrl}
                          alt={player.name}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <span className="text-sm">{player.name}</span>
                    </div>
                  ))}
                </div>
                <div>
                  {match.team2Players.map(player => (
                    <div key={player.id} className="flex items-center mb-1">
                      <div className="relative w-6 h-6 rounded-full overflow-hidden mr-2">
                        <Image
                          src={player.photoUrl}
                          alt={player.name}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <span className="text-sm">{player.name}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
          {matches.filter(match => match.status === 'ongoing').length === 0 && (
            <p className="text-gray-500 text-center py-4">Ei käynnissä olevia pelejä</p>
          )}
        </div>
      </div>

      {/* Completed games */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-4">Päättyneet pelit</h2>
        <div className="space-y-4">
          {matches.filter(match => match.status === 'completed').map(match => (
            <div key={match.id} className="border rounded-lg p-4">
              <div className="mb-4">
                <div className="font-medium">
                  {match.team1Name || `Joukkue ${match.team1Players.map(p => p.name).join(' & ')}`}
                  <span className="mx-2 text-gray-400">vs</span>
                  {match.team2Name || `Joukkue ${match.team2Players.map(p => p.name).join(' & ')}`}
                </div>
                <div className="text-sm text-gray-500 mt-1">
                  Pelattu: {new Date(match.createdAt).toLocaleString('fi-FI')}
                </div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div className={match.winners.some(w => match.team1Players.find(p => p.id === w.id)) ? "text-blue-800" : "text-gray-500"}>
                  {match.team1Players.map(player => (
                    <div key={player.id} className="flex items-center mb-1">
                      <div className="relative w-6 h-6 rounded-full overflow-hidden mr-2">
                        <Image
                          src={player.photoUrl}
                          alt={player.name}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <span className="text-sm">{player.name}</span>
                      {match.winners.find(w => w.id === player.id) && (
                        <span className="ml-2 text-sm">👑</span>
                      )}
                    </div>
                  ))}
                </div>
                <div className={match.winners.some(w => match.team2Players.find(p => p.id === w.id)) ? "text-purple-800" : "text-gray-500"}>
                  {match.team2Players.map(player => (
                    <div key={player.id} className="flex items-center mb-1">
                      <div className="relative w-6 h-6 rounded-full overflow-hidden mr-2">
                        <Image
                          src={player.photoUrl}
                          alt={player.name}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <span className="text-sm">{player.name}</span>
                      {match.winners.find(w => w.id === player.id) && (
                        <span className="ml-2 text-sm">👑</span>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          ))}
          {matches.filter(match => match.status === 'completed').length === 0 && (
            <p className="text-gray-500 text-center py-4">Ei päättyneitä pelejä</p>
          )}
        </div>
      </div>
    </div>
  );
};

export default BeerPongGame;

================
File: src/components/games/DartGame.tsx
================
"use client";

import { useState, useEffect } from "react";
import Leaderboard from "@/components/Leaderboard";

interface Score {
  id: string;
  score: number;
  createdAt: string;
  user: {
    name: string;
    username: string;
    photoUrl: string;
  };
}

export default function DartGame() {
  const [score, setScore] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  const [leaderboard, setLeaderboard] = useState<Score[]>([]);

  // Fetch leaderboard
  const fetchLeaderboard = async () => {
    try {
      const response = await fetch("/api/games/darts");
      if (!response.ok) throw new Error("Tulosten haku epäonnistui");
      const data = await response.json();
      setLeaderboard(data);
    } catch (err) {
      console.error("Virhe tulosten haussa:", err);
    }
  };

  useEffect(() => {
    fetchLeaderboard();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError("");

    try {
      const scoreNum = parseInt(score);
      if (isNaN(scoreNum) || scoreNum < 0 || scoreNum > 50) {
        throw new Error("Pisteiden tulee olla väliltä 0-50");
      }

      const user = JSON.parse(sessionStorage.getItem("user") || "{}");
      if (!user.id) throw new Error("Kirjaudu sisään tallentaaksesi tuloksen");

      const response = await fetch("/api/games/darts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          score: scoreNum,
          userId: user.id,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Pisteiden tallennus epäonnistui");
      }

      setScore("");
      fetchLeaderboard();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Pisteiden tallennus epäonnistui");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="space-y-8">
      <div className="max-w-md mx-auto">
        <h2 className="text-2xl font-bold text-gray-900 mb-4">
          Tikanheitto (5 tikkaa, max 50 pistettä)
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="score" className="block text-sm font-medium text-gray-700">
              Pisteesi
            </label>
            <input
              type="number"
              id="score"
              min="0"
              max="50"
              required
              value={score}
              onChange={(e) => setScore(e.target.value)}
              className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="Syötä pisteet (0-50)"
            />
          </div>

          {error && (
            <div className="text-red-500 text-sm">{error}</div>
          )}

          <button
            type="submit"
            disabled={isSubmitting || !score}
            className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting ? "Tallennetaan..." : "Tallenna pisteet"}
          </button>
        </form>
      </div>

      <div>
        <h3 className="text-xl font-semibold text-gray-900 mb-4">Tulostaulu</h3>
        <Leaderboard scores={leaderboard} type="points" maxScore={50} />
      </div>
    </div>
  );
}

================
File: src/components/games/PuttingGame.tsx
================
"use client";

import { useState, useEffect } from "react";
import Leaderboard from "@/components/Leaderboard";

interface Score {
  id: string;
  score: number;
  createdAt: string;
  user: {
    name: string;
    username: string;
    photoUrl: string;
  };
}

export default function PuttingGame() {
  const [score, setScore] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState("");
  const [leaderboard, setLeaderboard] = useState<Score[]>([]);

  // Fetch leaderboard
  const fetchLeaderboard = async () => {
    try {
      const response = await fetch("/api/games/putting");
      if (!response.ok) throw new Error("Tulosten haku epäonnistui");
      const data = await response.json();
      setLeaderboard(data);
    } catch (err) {
      console.error("Virhe tulosten haussa:", err);
    }
  };

  useEffect(() => {
    fetchLeaderboard();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError("");

    try {
      const scoreNum = parseInt(score);
      if (isNaN(scoreNum) || scoreNum < 0 || scoreNum > 10) {
        throw new Error("Pisteiden tulee olla väliltä 0-10");
      }

      const user = JSON.parse(sessionStorage.getItem("user") || "{}");
      if (!user.id) throw new Error("Kirjaudu sisään tallentaaksesi tuloksen");

      const response = await fetch("/api/games/putting", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          score: scoreNum,
          userId: user.id,
        }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || "Pisteiden tallennus epäonnistui");
      }

      setScore("");
      fetchLeaderboard();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Pisteiden tallennus epäonnistui");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="space-y-8">
      <div className="max-w-md mx-auto">
        <h2 className="text-2xl font-bold text-gray-900 mb-4">
          Frisbeegolf puttaus (10 kiekkoa 10 metristä)
        </h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="score" className="block text-sm font-medium text-gray-700">
              Pisteesi
            </label>
            <input
              type="number"
              id="score"
              min="0"
              max="10"
              required
              value={score}
              onChange={(e) => setScore(e.target.value)}
              className="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="Syötä pisteet (0-10)"
            />
          </div>

          {error && (
            <div className="text-red-500 text-sm">{error}</div>
          )}

          <button
            type="submit"
            disabled={isSubmitting || !score}
            className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSubmitting ? "Tallennetaan..." : "Tallenna pisteet"}
          </button>
        </form>
      </div>

      <div>
        <h3 className="text-xl font-semibold text-gray-900 mb-4">Tulostaulu</h3>
        <Leaderboard scores={leaderboard} type="points" maxScore={10} />
      </div>
    </div>
  );
}

================
File: src/components/Leaderboard.tsx
================
import Image from 'next/image';

type Score = {
  id: string;
  user: {
    name: string;
    username: string;
    photoUrl: string;
  };
  score?: number;
  time?: number;
  createdAt: string;
};

interface LeaderboardProps {
  scores: Score[];
  type: 'points' | 'time';
  maxScore?: number;
}

export default function Leaderboard({ scores, type, maxScore }: LeaderboardProps) {
  return (
    <div className="bg-white rounded-lg shadow overflow-hidden">
      <table className="min-w-full">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Sija
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Pelaaja
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              {type === 'points' ? 'Pisteet' : 'Aika'}
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Päivämäärä
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {scores.map((score, index) => (
            <tr key={score.id} className={index === 0 ? 'bg-yellow-50' : ''}>
              <td className="px-6 py-4 whitespace-nowrap">
                <div className="text-sm font-medium text-gray-900">#{index + 1}</div>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <div className="flex items-center">
                  <div className="flex-shrink-0 h-10 w-10 relative">
                    <Image
                      src={score.user.photoUrl}
                      alt={score.user.name}
                      fill
                      className="rounded-full object-cover"
                    />
                  </div>
                  <div className="ml-4">
                    <div className="text-sm font-medium text-gray-900">
                      {score.user.name}
                    </div>
                    <div className="text-sm text-gray-500">
                      @{score.user.username}
                    </div>
                  </div>
                </div>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <div className="text-sm text-gray-900">
                  {type === 'points' ? (
                    <span>
                      {score.score}
                      {maxScore && <span className="text-gray-500">/{maxScore}</span>}
                    </span>
                  ) : (
                    <span>{score.time?.toFixed(2)}s</span>
                  )}
                </div>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {new Date(score.createdAt).toLocaleDateString('fi-FI')}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

================
File: src/components/Navbar.tsx
================
"use client";

import { useEffect, useState } from "react";
import { usePathname } from "next/navigation";
import Link from "next/link";
import Image from "next/image";

interface User {
  name: string;
  photoUrl: string;
}

export default function Navbar() {
  const [user, setUser] = useState<User | null>(null);
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const pathname = usePathname();

  useEffect(() => {
    const storedUser = sessionStorage.getItem("user");
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
  }, []);

  // Close menu when route changes
  useEffect(() => {
    setIsMenuOpen(false);
  }, [pathname]);

  return (
    <nav className="bg-white shadow-lg">
      <div className="max-w-7xl mx-auto px-4">
        <div className="flex justify-between h-16">
          <div className="flex items-center">
            <Link
              href={user ? "/party" : "/"}
              className="flex items-center px-2 py-2 text-gray-700 hover:text-gray-900"
            >
              <span className="text-xl font-bold">Juhlat</span>
            </Link>
          </div>

          {/* Hamburger menu button */}
          <div className="flex items-center sm:hidden">
            <button
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              className="inline-flex items-center justify-center p-2 rounded-md text-gray-700 hover:text-gray-900 hover:bg-gray-100 focus:outline-none"
            >
              <svg
                className="h-6 w-6"
                stroke="currentColor"
                fill="none"
                viewBox="0 0 24 24"
              >
                {isMenuOpen ? (
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                ) : (
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M4 6h16M4 12h16M4 18h16"
                  />
                )}
              </svg>
            </button>
          </div>

          {/* Desktop navigation */}
          <div className="hidden sm:flex sm:items-center sm:space-x-4">
            {user ? (
              <>
                <Link
                  href="/menu"
                  className={`px-3 py-2 rounded-lg ${
                    pathname === "/menu"
                      ? "bg-blue-100 text-blue-700"
                      : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                  }`}
                >
                  Ruokalista
                </Link>
                <Link
                  href="/games"
                  className={`px-3 py-2 rounded-lg ${
                    pathname === "/games"
                      ? "bg-blue-100 text-blue-700"
                      : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                  }`}
                >
                  Pelit
                </Link>
                <Link
                  href="/icebreaker"
                  className={`px-3 py-2 rounded-lg ${
                    pathname === "/icebreaker"
                      ? "bg-blue-100 text-blue-700"
                      : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                  }`}
                >
                  Tutustumispeli
                </Link>
                <Link
                  href="/records"
                  className={`px-3 py-2 rounded-lg ${
                    pathname === "/records"
                      ? "bg-blue-100 text-blue-700"
                      : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                  }`}
                >
                  Tulokset
                </Link>
                <Link
                  href="/party"
                  className={`flex items-center px-3 py-2 rounded-lg ${
                    pathname === "/party"
                      ? "bg-blue-100"
                      : "hover:bg-gray-100"
                  }`}
                >
                  <div className="relative w-8 h-8 rounded-full overflow-hidden mr-2">
                    <Image
                      src={user.photoUrl}
                      alt={user.name}
                      fill
                      className="object-cover"
                    />
                  </div>
                  <span className="text-gray-700">{user.name}</span>
                </Link>
              </>
            ) : (
              <>
                <Link
                  href="/signin"
                  className="px-3 py-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-lg"
                >
                  Kirjaudu sisään
                </Link>
                <Link
                  href="/signup"
                  className="px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  Luo tili
                </Link>
              </>
            )}
          </div>
        </div>
      </div>

      {/* Mobile menu */}
      <div className={`${isMenuOpen ? "block" : "hidden"} sm:hidden bg-white border-t`}>
        <div className="px-2 pt-2 pb-3 space-y-1">
          {user ? (
            <>
              <Link
                href="/menu"
                className={`block px-3 py-2 rounded-lg ${
                  pathname === "/menu"
                    ? "bg-blue-100 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                Ruokalista
              </Link>
              <Link
                href="/games"
                className={`block px-3 py-2 rounded-lg ${
                  pathname === "/games"
                    ? "bg-blue-100 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                Pelit
              </Link>
              <Link
                href="/icebreaker"
                className={`block px-3 py-2 rounded-lg ${
                  pathname === "/icebreaker"
                    ? "bg-blue-100 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                Tutustumispeli
              </Link>
              <Link
                href="/records"
                className={`block px-3 py-2 rounded-lg ${
                  pathname === "/records"
                    ? "bg-blue-100 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                Tulokset
              </Link>
              <Link
                href="/party"
                className={`flex items-center px-3 py-2 rounded-lg ${
                  pathname === "/party"
                    ? "bg-blue-100"
                    : "hover:bg-gray-100"
                }`}
              >
                <div className="relative w-8 h-8 rounded-full overflow-hidden mr-2">
                  <Image
                    src={user.photoUrl}
                    alt={user.name}
                    fill
                    className="object-cover"
                  />
                </div>
                <span className="text-gray-700">{user.name}</span>
              </Link>
            </>
          ) : (
            <>
              <Link
                href="/signin"
                className="block px-3 py-2 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-lg"
              >
                Kirjaudu sisään
              </Link>
              <Link
                href="/signup"
                className="block px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
              >
                Luo tili
              </Link>
            </>
          )}
        </div>
      </div>
    </nav>
  );
}

================
File: src/lib/beerpong.ts
================
import { prisma } from './prisma';

interface User {
  id: string;
  name: string;
  username: string;
  photoUrl: string;
}

interface BeerPongStats {
  userId: string;
  user: User;
  wins: number;
  losses: number;
  winStreak: number;
  bestStreak: number;
  lastUpdated: Date;
}

interface LeaderboardEntry extends User {
  wins: number;
  losses: number;
  winStreak: number;
  bestStreak: number;
  winPercentage: number;
  totalGames: number;
}

export async function updateBeerPongStats(
  winnerIds: string[],
  loserIds: string[]
) {
  try {
    // Update winners
    for (const winnerId of winnerIds) {
      const userStats = await prisma.beerPongStats.findUnique({
        where: { userId: winnerId },
      });

      if (userStats) {
        // Update existing stats
        await prisma.beerPongStats.update({
          where: { userId: winnerId },
          data: {
            wins: userStats.wins + 1,
            winStreak: userStats.winStreak + 1,
            bestStreak: Math.max(userStats.bestStreak, userStats.winStreak + 1),
            lastUpdated: new Date(),
          },
        });
      } else {
        // Create new stats
        await prisma.beerPongStats.create({
          data: {
            userId: winnerId,
            wins: 1,
            winStreak: 1,
            bestStreak: 1,
          },
        });
      }
    }

    // Update losers
    for (const loserId of loserIds) {
      const userStats = await prisma.beerPongStats.findUnique({
        where: { userId: loserId },
      });

      if (userStats) {
        // Update existing stats
        await prisma.beerPongStats.update({
          where: { userId: loserId },
          data: {
            losses: userStats.losses + 1,
            winStreak: 0,
            lastUpdated: new Date(),
          },
        });
      } else {
        // Create new stats
        await prisma.beerPongStats.create({
          data: {
            userId: loserId,
            losses: 1,
            winStreak: 0,
            bestStreak: 0,
          },
        });
      }
    }
  } catch (error) {
    console.error('Error updating beer pong stats:', error);
    throw error;
  }
}

export async function getLeaderboard(): Promise<LeaderboardEntry[]> {
  try {
    const stats = await prisma.beerPongStats.findMany({
      include: {
        user: {
          select: {
            id: true,
            name: true,
            username: true,
            photoUrl: true,
          },
        },
      },
      orderBy: [
        { wins: 'desc' },
        { winStreak: 'desc' },
      ],
    });

    return stats.map((stat: BeerPongStats): LeaderboardEntry => ({
      ...stat.user,
      wins: stat.wins,
      losses: stat.losses,
      winStreak: stat.winStreak,
      bestStreak: stat.bestStreak,
      winPercentage: stat.wins + stat.losses > 0 
        ? Math.round((stat.wins / (stat.wins + stat.losses)) * 100)
        : 0,
      totalGames: stat.wins + stat.losses,
    }));
  } catch (error) {
    console.error('Error fetching leaderboard:', error);
    throw error;
  }
}

================
File: src/lib/icebreaker.ts
================
import { promises as fs } from 'fs';
import path from 'path';
import { prisma } from './prisma';

interface Question {
  number: number;
  text: string;
}

interface Card {
  id: number;
  set: number;
  title: string;
  subtitle: string;
  questions: Question[];
}

export async function loadCards(): Promise<Card[]> {
  const filePath = path.join(process.cwd(), 'tutustumiskortit.json');
  const fileContents = await fs.readFile(filePath, 'utf8');
  return JSON.parse(fileContents);
}

export async function assignCardToUser(userId: string): Promise<{
  id: string;
  cardId: number;
  questions: Question[];
}> {
  // Get all assigned cards to find the next available card number
  const assignedCards = await prisma.icebreakerCard.findMany({
    orderBy: { cardId: 'desc' },
  });

  // Load all cards
  const allCards = await loadCards();
  const totalCards = allCards.length;

  // Find the next card ID to assign
  let nextCardId = 1;
  if (assignedCards.length > 0) {
    const lastCardId = assignedCards[0].cardId;
    nextCardId = lastCardId >= totalCards ? 1 : lastCardId + 1;
  }

  // Find the card with this ID
  const card = allCards.find(c => c.id === nextCardId);
  if (!card) {
    throw new Error('Card not found');
  }

  // Create the card assignment
  const newCard = await prisma.icebreakerCard.create({
    data: {
      cardId: nextCardId,
      userId,
    }
  });

  return {
    id: newCard.id,
    cardId: nextCardId,
    questions: card.questions
  };
}

export async function submitAnswer(
  cardId: string,
  questionNumber: number,
  giverId: string,
  receiverId: string
): Promise<void> {
  // Find the IcebreakerCard first to get its ID
  const card = await prisma.icebreakerCard.findUnique({
    where: { id: cardId }
  });

  if (!card) {
    throw new Error('Card not found');
  }

  await prisma.icebreakerAnswer.create({
    data: {
      cardId,
      questionNumber,
      giverId,
      receiverId,
    }
  });
}

export async function getCardWithAnswers(userId: string) {
  const assignedCard = await prisma.icebreakerCard.findFirst({
    where: { userId },
    include: {
      answers: {
        include: {
          receiver: {
            select: {
              id: true,
              name: true,
              username: true,
              photoUrl: true,
            }
          }
        }
      }
    }
  });

  if (!assignedCard) {
    return null;
  }

  const cards = await loadCards();
  const cardData = cards.find(c => c.id === assignedCard.cardId);

  if (!cardData) {
    throw new Error('Card data not found');
  }

  // Return combined data with database ID
  return {
    dbId: assignedCard.id,
    cardId: assignedCard.cardId,
    title: cardData.title,
    subtitle: cardData.subtitle,
    questions: cardData.questions,
    answers: assignedCard.answers.reduce((acc: Record<number, {
      id: string;
      name: string;
      username: string;
      photoUrl: string;
    }>, answer: {
      questionNumber: number;
      receiver: {
        id: string;
        name: string;
        username: string;
        photoUrl: string;
      }
    }) => {
      acc[answer.questionNumber] = answer.receiver;
      return acc;
    }, {})
  };
}

export async function getParticipants() {
  return prisma.user.findMany({
    select: {
      id: true,
      name: true,
      username: true,
      photoUrl: true,
    },
    orderBy: {
      name: 'asc',
    }
  });
}

================
File: src/lib/prisma.ts
================
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================
File: src/types/user.ts
================
export interface User {
  id: string;
  name: string;
  username: string;
  photoUrl: string;
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: .repomixignore
================
tutustumiskortit.json

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['res.cloudinary.com'],
  },
};

module.exports = nextConfig;

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: package.json
================
{
  "name": "saku30v",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@prisma/client": "^6.8.2",
    "cloudinary": "^2.6.1",
    "next": "15.3.2",
    "prisma": "^6.8.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================================
End of Codebase
================================================================
